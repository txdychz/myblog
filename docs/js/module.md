# 模块化

## 模块化的演变过程

阶段 1
一个 js 文件一个模块，模块没有私有作用域
阶段 2
每个文件导出一个全局对象，将函数和变量都放在里面
阶段 3
使用立即执行函数

首先 node 推出了模块化标准 cjs，所以 node 中执行的 js 代码必须遵守 cjs 规范。cjs 同步加载的，浏览器使用的话会阻塞
渲染，
因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。
因此，浏览器端的模块，不能采用"同步加载"（synchronous），只能采用"异步加载"（asynchronous）。这就是 AMD 规范诞生的背景。
专门为浏览器、设计了另一种模块化规范 AMD（async modules definition），后来又出现了 CMD，CMD 简化了 AMD，
最终 ES6 的模块化成为了浏览器最终的模块化方案，在 nodejs 使用 cjs

## commjs 如何封装私有变量

导出的时候只导出一个对象，设置要导出变量的 get 属性访问器和操作值的函数

## esm

1. 模块内部默认使用严格模式，所以 this 为默认为 undefined
2. 每个模块都有独立作用域
3. 需要服务器支持 cors
4. 默认 defer 延迟执行

## cjs 和 esm 的区别

1. Commonjs 是拷贝输出（原模块的基本数据类型值改变，不会影响引入的值，引用类型会），ES6 模块化是引用输出（动态只读引用）
2. Commonjs 是运行时加载，ES6 模块化是编译时输出接口
3. Commonjs 是单个值导出，ES6 模块化可以多个值导出
4. Commonjs 是动态语法可写在函数体中，ES6 模块化静态语法只能写在顶层
5. Commonjs 的 this 是当前模块化，ES6 模块化的 this 是 undefined
