# ECMASCRIPT

## 作用域

### 作用域是什么

变量声明的位置和作用范围
收集并维护由所有声明的变量，确定当前执行代码对标识符的访问权限。

《你不知道的 javascript》对作用域的解释是，是 js 引擎查找变量的一套规则，如何找，在哪找。

js 作用域有三种，全局、函数、es6块级作用域

### 为什么会有作用域 

保存变量、查找变量、隔离变量防止命名冲突

### 作用域应用场景(How)

#### 预解析

变量提升，var 声明的变量，function 声明的函数会提升到作用域的顶部，并且函数声明优先于变量声明
在函数内部，形参和实参结合之后才进行变量/函数提升

#### 作用域链

当函数被执行的时候，产生函数的执行上下文，每个执行上下文都有变量对象，多个变量对象组合成立作用域链，当前执行函数的变量对象处于作用域链顶端

### 如何修改作用域

欺骗词法

#### 第一种：eval

eval 函数会将参数字符串当作当前作用域的代码执行

#### 第二种：with 关键字

利用 with 关键字传入目标对象
with 内部代码的变量会从对象中查找

## this

### this 是什么



### this 是怎么产生的

1. 函数被调用的时候，创建执行上下文的时候

2. new 的时候

### this 的应用

### 改变 this 的方法

## 原型

### 原型是什么

原型是一个对象，实例对象都有隐式原型，构造函数有显示原型，

### 原型有什么用

给实例对象添加属性和方法，一般是方法

### 原型是怎么产生的

当对象被创建的时候，会将对象的隐式原型指向构造函数的显式原型



### 原型链

当读取对象的属性的时候，如果当前对象没有该属性，js引擎会从对象的隐式原型，沿着原型链一直往上找。



### 应用

#### 项目的loading加载过渡组件

在项目中给Vue构造函数的原型中添加一个loading方法，给body添加一个遮罩层动画

### 

## 闭包

### 什么是闭包（what）

闭包就是，外层函数作用域被内层函数引用时候，就会产生闭包。闭包就是内层函数和外部函数作用域的组合。

### 闭包是怎么产生的(why)

函数嵌套
外部函数变量被内部函数引用

### 闭包的应用场景，怎么用（How）

高阶函数，私有变量，模块坏

节流防抖，函数柯里化，管道函数

### 闭包的好处和坏处

#### 好处

可以用变量保存闭包来延长变量的生命周期。

保护变量，防止被篡改。

#### 坏处

如果不及时释放就会一直占内存，造成内存泄漏或内存溢出



## 变量

#### var关键字

1. 有函数作用域
2. 可重复声明
3. 变量提升
4. 全局定义的变量作为window属性



## 运算符



### 相等

js中的相等比较算法有以下四种：

​	1.    The **Abstract** Equality Comparison Algorithm (==)      

​	2.    The **Strict** Equality Comparison Algorithm (===)        

​	3.    SameValue (Object.is())        (附：这里NaN和NaN相等，0和-0不相等)

​	4.    SameValueZero (暂未提供API)   (附：这里NaN和NaN相等，0和-0和+0都是相等的) 

#### SameValue (Object.is()) 



```
Object.is(NaN,NaN); //true

Object.is(0,-0);   //false

Object.is(0,+0);   //true

Object.is(+0,-0);  //false
```

1）我们知道NaN==NaN是false，NaN===NaN也是false， 但是SameValue算法里，NaN和NaN是相等的。

2）SameValue算法里**0默认是+0**，同时 0 和 -0 是不相等的（+0和-0也不相等）。

#### SameValueZero (暂未提供API) 

SameValueZero算法和SameValue算法的区别在于对0的处理（认为0、+0以及-0三者是相等的），其他的和SameValue一样（例如NaN和NaN是相等的）

```
例一：
[NaN].includes(NaN);  //true
[0].includes(-0);  //true
[0].includes(+0);  //true  例二：
const a = new Set();
a.add(0);
a.add(NaN);
 
a.has(-0);  //true
a.has(+0);  //true
a.has(NaN); //true
```

includes()内部使用的比较算法就是SameValueZero

new Set()、new Map()比较是用的算法也是SameValueZero（+0和-0和0都是相等的，NaN和NaN也是相等的）